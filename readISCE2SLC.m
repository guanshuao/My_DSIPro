function [slcData, metadata] = readISCE2SLC(slcFilename, varargin)
%READISCE2SLC 读取ISCE2处理的SLC格式文件
%
%   [slcData, metadata] = readISCE2SLC(slcFilename)
%   [slcData, metadata] = readISCE2SLC(slcFilename, 'Name', Value, ...)
%
%   输入参数: 
%       slcFilename - SLC文件路径 (字符串或字符数组)
%                     函数会自动查找对应的 .xml 文件获取元数据
%
%   可选Name-Value参数:
%       'Width'     - 图像宽度（如果不想从XML读取）
%       'Length'    - 图像高度/行数（如果不想从XML读取）
%       'ByteOrder' - 字节序:  'l'小端(默认), 'b'大端
%       'DataType'  - 数据类型:  'cfloat'(默认), 'cfloat64'
%       'Subset'    - 读取子区域 [startRow, endRow, startCol, endCol]
%
%   输出参数:
%       slcData  - 复数矩阵 (length x width)
%       metadata - 结构体，包含从XML读取的元数据信息
%
%   示例: 
%       % 直接读取（自动解析XML）
%       [slc, meta] = readISCE2SLC('20200101.slc');
%
%       % 手动指定尺寸
%       slc = readISCE2SLC('data.slc', 'Width', 5000, 'Length', 10000);
%
%       % 读取子区域
%       slc = readISCE2SLC('data.slc', 'Subset', [1000, 2000, 500, 1500]);
%
%   注意: 
%       1. ISCE2的SLC文件为二进制格式，存储单精度复数(complex64)
%       2. 每个复数由两个float32组成（实部+虚部，共8字节/像素）
%       3. 函数会自动查找 .slc. xml 文件获取宽度、高度等信息
%
%   See also:  readISCE2XML, fread, complex
%
%   Author: Generated by GitHub Copilot
%   Date: 2025-12-20

    % 解析输入参数
    p = inputParser;
    addRequired(p, 'slcFilename', @(x) ischar(x) || isstring(x));
    addParameter(p, 'Width', [], @isnumeric);
    addParameter(p, 'Length', [], @isnumeric);
    addParameter(p, 'ByteOrder', 'l', @(x) ismember(lower(x), {'l', 'b', 'little', 'big'}));
    addParameter(p, 'DataType', 'cfloat', @ischar);
    addParameter(p, 'Subset', [], @(x) isnumeric(x) && (isempty(x) || numel(x)==4));
    parse(p, slcFilename, varargin{:});
    
    opts = p.Results;
    slcFilename = char(opts.slcFilename);
    
    % 初始化元数据结构
    metadata = struct();
    metadata.filename = slcFilename;
    
    % 尝试读取XML文件获取元数据
    xmlFilename = [slcFilename, '.xml'];
    if exist(xmlFilename, 'file')
        metadata = parseISCE2XML(xmlFilename, metadata);
    end
    
    % 尝试读取VRT文件（备用方案）
    vrtFilename = [slcFilename, '.vrt'];
    if exist(vrtFilename, 'file') && ~isfield(metadata, 'width')
        metadata = parseISCE2VRT(vrtFilename, metadata);
    end
    
    % 确定图像尺寸
    if ~isempty(opts.Width)
        width = opts.Width;
    elseif isfield(metadata, 'width')
        width = metadata.width;
    else
        error('无法确定图像宽度。请提供XML文件或手动指定Width参数。');
    end
    
    if ~isempty(opts.Length)
        length_img = opts.Length;
    elseif isfield(metadata, 'length')
        length_img = metadata.length;
    else
        % 尝试从文件大小推断
        fileInfo = dir(slcFilename);
        if ~isempty(fileInfo)
            % CFLOAT = 8 bytes per pixel (2 x float32)
            bytesPerPixel = 8;
            length_img = floor(fileInfo.bytes / (width * bytesPerPixel));
            warning('从文件大小推断图像长度为 %d 行', length_img);
        else
            error('无法确定图像长度。请提供XML文件或手动指定Length参数。');
        end
    end
    
    % 确定字节序
    byteOrder = lower(opts.ByteOrder);
    if isfield(metadata, 'byteOrder')
        byteOrder = lower(metadata.byteOrder);
    end
    
    if ismember(byteOrder, {'l', 'little'})
        machineFormat = 'ieee-le';
    else
        machineFormat = 'ieee-be';
    end
    
    % 确定数据类型
    dataType = lower(opts.DataType);
    if isfield(metadata, 'dataType')
        dataType = lower(metadata.dataType);
    end
    
    switch dataType
        case {'cfloat', 'cfloat32', 'complex64'}
            precision = 'float32';
            bytesPerElement = 4;
        case {'cfloat64', 'cdouble', 'complex128'}
            precision = 'float64';
            bytesPerElement = 8;
        otherwise
            precision = 'float32';
            bytesPerElement = 4;
    end
    
    % 更新元数据
    metadata.width = width;
    metadata.length = length_img;
    metadata.byteOrder = byteOrder;
    metadata.dataType = dataType;
    
    % 打开文件
    fid = fopen(slcFilename, 'rb', machineFormat);
    if fid == -1
        error('无法打开文件:  %s', slcFilename);
    end
    
    cleanupObj = onCleanup(@() fclose(fid));
    
    % 处理子区域读取
    if ~isempty(opts.Subset)
        subset = opts.Subset;
        startRow = max(1, subset(1));
        endRow = min(length_img, subset(2));
        startCol = max(1, subset(3));
        endCol = min(width, subset(4));
        
        numRows = endRow - startRow + 1;
        numCols = endCol - startCol + 1;
        
        % 预分配输出数组
        slcData = complex(zeros(numRows, numCols, 'single'));
        
        % 逐行读取子区域
        bytesPerRow = width * 2 * bytesPerElement;
        bytesPerPixel = 2 * bytesPerElement;
        
        for row = 1:numRows
            % 跳到对应行的起始位置
            rowOffset = (startRow + row - 2) * bytesPerRow;
            colOffset = (startCol - 1) * bytesPerPixel;
            fseek(fid, rowOffset + colOffset, 'bof');
            
            % 读取该行的数据
            rowData = fread(fid, [2, numCols], precision);
            slcData(row, :) = complex(rowData(1,: ), rowData(2,:));
        end
        
        metadata.subset = [startRow, endRow, startCol, endCol];
    else
        % 读取整个文件
        % 每个复数像素由2个浮点数组成（实部+虚部）
        rawData = fread(fid, [2, width * length_img], precision);
        
        % 重组为复数矩阵
        slcData = complex(rawData(1,: ), rawData(2,:));
        slcData = reshape(slcData, [width, length_img])';
    end
    
    fprintf('成功读取SLC文件: %s\n', slcFilename);
    fprintf('  尺寸: %d 行 x %d 列\n', size(slcData, 1), size(slcData, 2));
end


function metadata = parseISCE2XML(xmlFilename, metadata)
%PARSEISCE2XML 解析ISCE2的XML元数据文件
    
    try
        xmlDoc = xmlread(xmlFilename);
        
        % 获取所有property元素
        properties = xmlDoc.getElementsByTagName('property');
        
        for i = 0:properties.getLength()-1
            prop = properties. item(i);
            name = char(prop.getAttribute('name'));
            
            % 获取value子元素
            valueNodes = prop.getElementsByTagName('value');
            if valueNodes.getLength() > 0
                value = char(valueNodes.item(0).getTextContent());
                
                switch lower(name)
                    case 'width'
                        metadata.width = str2double(value);
                    case 'length'
                        metadata.length = str2double(value);
                    case 'number_bands'
                        metadata.bands = str2double(value);
                    case 'data_type'
                        metadata.dataType = value;
                    case 'byte_order'
                        metadata.byteOrder = value;
                    case 'scheme'
                        metadata.scheme = value;
                    case 'image_type'
                        metadata.imageType = value;
                end
            end
        end
        
        % 尝试获取coordinate1 (width) 和 coordinate2 (length) - 新格式
        coord1 = xmlDoc.getElementsByTagName('coordinate1');
        if coord1.getLength() > 0
            sizeNodes = coord1.item(0).getElementsByTagName('size');
            if sizeNodes.getLength() > 0
                metadata.width = str2double(char(sizeNodes. item(0).getTextContent()));
            end
        end
        
        coord2 = xmlDoc.getElementsByTagName('coordinate2');
        if coord2.getLength() > 0
            sizeNodes = coord2.item(0).getElementsByTagName('size');
            if sizeNodes.getLength() > 0
                metadata.length = str2double(char(sizeNodes.item(0).getTextContent()));
            end
        end
        
    catch ME
        warning('解析XML文件时出错: %s', ME.message);
    end
end


function metadata = parseISCE2VRT(vrtFilename, metadata)
%PARSEISCE2VRT 解析ISCE2的VRT文件获取基本信息
    
    try
        xmlDoc = xmlread(vrtFilename);
        root = xmlDoc.getDocumentElement();
        
        % 获取rasterXSize和rasterYSize属性
        if root.hasAttribute('rasterXSize')
            metadata.width = str2double(char(root.getAttribute('rasterXSize')));
        end
        if root.hasAttribute('rasterYSize')
            metadata.length = str2double(char(root.getAttribute('rasterYSize')));
        end
        
    catch ME
        warning('解析VRT文件时出错: %s', ME.message);
    end
end